#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Author: Luca Gioacchini

"""
CowrieParser is a subclass of HoneypotParser for parsing log files generated by 
the Cowrie honeypot. It provides methods for extracting labels related to 
exploiters and bruteforcers attacks from the log data.
"""

from parser import HoneypotParser
from io import BytesIO
import pandas as pd
import gzip
import json

MIN_FREQ = 10

class CowrieParser(HoneypotParser):
    def __init__(self, filepath, outpath=None):
        """
        Class for parsing and extracting labels from Cowrie log data.

        Parameters
        ----------
        filepath : str
            The file path of the log file to be parsed.
        outpath : str, optional
            The file path of the output file to which the extracted labels 
            should be saved. If not provided, the labels will not be saved 
            to a file.

        Attributes
        ----------
        filepath : str
            The file path of the log file to be parsed.
        outpath : str, optional
            The file path of the output file to which the extracted labels 
            should be saved. If not provided, the labels will not be saved 
            to a file.
        logs : list of str
            A list of strings representing the rows of the log file.

        """
        super().__init__(filepath, outpath)

    def load_log_file(self, filepath):
        """
        Load the log file from the specified file path.

        Parameters
        ----------
        filepath : str
            The file path of the log file to be loaded.

        Returns
        -------
        list
            A list of strings representing the rows of the log file.

        """
        # Read the bytes object into a file-like object
        if filepath.endswith("gz"):
            with gzip.open(filepath, 'rb') as f_in:
                file_like_obj = BytesIO(f_in.read())
        else:
            with open(filepath, 'rb') as f_in:
                file_like_obj = BytesIO(f_in.read())

        # Convert the data in the file-like object to a string
        data_string = file_like_obj.getvalue()

        # Decode the string using the utf-8 character encoding and split the
        # rows
        data_string = data_string.decode('utf-8')
        logs = data_string.split('\n')

        return logs

    def _get_ips_frequency(self, entries):
        """
        Filter the IP addresses according to their frequency of occurrence in 
        the input list.

        Parameters
        ----------
        entries : list of tuple
            A list of tuples containing IP addresses and labels.

        Returns
        -------
        list
            A list of tuples containing IP addresses and labels, filtered to 
            include only IP addresses that occur at least 20 times in the input 
            list.

        """
        # Create a DataFrame from the list of bruteforcer IPs
        df = pd.DataFrame(entries, columns=['src_ip', 'label1', 'label2', 'label3'])
        # Count the number of occurrences of each IP address in the DataFrame
        ip_counts = df.value_counts('src_ip')
        # Extract the IP addresses that occur at least MIN_FREQ times
        bf_ips = ip_counts[ip_counts >= MIN_FREQ].index
        # Filter the DataFrame to include only the IP addresses that occur at 
        # least MIN_FREQ times
        filtered_df = df[df['src_ip'].isin(bf_ips)]
        # Remove duplicate rows from the DataFrame
        filtered_df = filtered_df.drop_duplicates()
        # Update the bruteforcers list with the filtered list of IP addresses
        entries = filtered_df.values.tolist()

        return entries


    def _extract_bruteforcer_label(self, label1=None, label2=None, label3=None):
        """
        Extract the IP addresses of bruteforcers from the logs.

        Parameters
        ----------
        label1 : str, optional
            The first label to be applied to the IP addresses of bruteforcers.
            Defaults to 'malicious'.
        label2 : str, optional
            The second label to be applied to the IP addresses of bruteforcers.
            Defaults to 'bruteforcer'.
        label3 : str, optional
            The third label to be applied to the IP addresses of bruteforcers.
            Defaults to 'unk_bruteforcer'.

        Returns
        -------
        list
            A list of tuples containing IP addresses and labels for bruteforcer 
            activity.

        """
        label1 = label1 or 'malicious'
        label2 = label2 or 'bruteforcer'
        label3 = label3 or 'unk_bruteforcer'

        # Extract the IP addresses of bruteforcers from the logs
        bfs = []
        for entry in self.logs:
            try:
                # Check if the entry contains the word `login`
                if 'login' in entry:
                    # Parse the entry as JSON and extract the source IP address
                    obj = json.loads(entry)
                    src_ip = obj['src_ip']

                    # Add the IP address to the list of bruteforcers if it's
                    label = (src_ip, label1, label2, label3)
                    bfs.append(label)
            except:
                # Skip the entry if it can't be parsed as JSON
                continue
        
        # Trim the entries according to the number of login attempts
        bfs = self._get_ips_frequency(bfs)
        bfs = [tuple(x) for x in bfs]

        return bfs

    def _extract_exploiter_label(self, label1=None, label2=None, label3=None):
        """
        Extract the IP addresses of exploiters from the logs.

        Parameters
        ----------
        label1 : str, optional
            The first label to be applied to the IP addresses of exploiters.
            Defaults to 'malicious'.
        label2 : str, optional
            The second label to be applied to the IP addresses of exploiters.
            Defaults to 'exploiter'.
        label3 : str, optional
            The third label to be applied to the IP addresses of exploiters.
            Defaults to 'unk_exploiter'.

        Returns
        -------
        list
            A list of tuples containing IP addresses and labels for exploiter 
            activity.

        """
        label1 = label1 or 'malicious'
        label2 = label2 or 'exploiter'
        label3 = label3 or 'unk_exploiter'

        # Extract the IP addresses of exploiters from the logs
        exploiters = []
        for entry in self.logs:
            try:
                obj = json.loads(entry)
                src_ip = obj['src_ip']
                command = obj['input']
                # Check if the IP downloaded a file
                if 'wget' in command or 'curl' in command or 'tftp' in command:
                    # Parse the entry as JSON and extract the IP address


                    # Add the IP address to the list of exploiters if it's not 
                    label = (src_ip, label1, label2, label3)
                    # Get only unique senders
                    if label not in exploiters:
                        exploiters.append(label)
            except:
                # Skip the entry if it can't be parsed as JSON
                continue

        return exploiters

    def _extract_miners_label(self, label1=None, label2=None, label3=None):
        """
        Extract the IP addresses of miners from the logs.

        Parameters
        ----------
        label1 : str, optional
            The first label to be applied to the IP addresses of exploiters.
            Defaults to 'malicious'.
        label2 : str, optional
            The second label to be applied to the IP addresses of exploiters.
            Defaults to 'exploiter'.
        label3 : str, optional
            The third label to be applied to the IP addresses of exploiters.
            Defaults to 'unk_miners'.

        Returns
        -------
        list
            A list of tuples containing IP addresses and labels for mining
            activity.

        """
        label1 = label1 or 'malicious'
        label2 = label2 or 'exploiter'
        label3 = label3 or 'unk_miners'

        # Extract the IP addresses of unk_miners from the logs
        miners = []
        for entry in self.logs:
            try:
                obj = json.loads(entry)
                src_ip = obj['src_ip']

                # command = obj['input']
                # Check if the IP downloaded a file
                if 'miner' in entry or 'hive-passwd' in entry:
                    # Parse the entry as JSON and extract the IP address


                    # Add the IP address to the list of miners if it's not
                    label = (src_ip, label1, label2, label3)
                    # Get only unique senders
                    if label not in miners:
                        miners.append(label)
            except:
                # Skip the entry if it can't be parsed as JSON
                continue

        return miners

    def extract_labels(self):
        """
        Extract labels from the log data.

        Returns
        -------
        list
            A list of tuples containing IP addresses and labels for bruteforcer 
            and exploiter activity.

        """
        # Extract the IP addresses labeled as bruteforcer from the log data
        bfs_ips = self._extract_bruteforcer_label()
        # Extract the IP addresses labeled as exploiters from the log data
        expl_ips = self._extract_exploiter_label()
        # Extract the IP addresses labeled as miners from the log data
        miners_ips = self._extract_miners_label()
        
        # Concatenate labels
        cowrie_all = bfs_ips + expl_ips + miners_ips

        # If an output file path has been specified, save the labels to the file
        if self.outpath:
            self.save_labels(cowrie_all)

        # Return the list of tuples containing the IP addresses and labels
        return cowrie_all
